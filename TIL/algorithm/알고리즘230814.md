# 2023.08.14(월)

# 알고리즘

### 계산기

1. 중위 표기법의 수식을 후위 표기법으로 변경
2. 후위 표기법의 수식을 스택을 이용하여 계산

| 토큰 | isp | icp |
| --- | --- | --- |
| ) | - | - |
| * /  | 2 | 2 |
| + - | 1 | 1 |
| ( | 0 | 34 |
- 연산자면 스택에서 피연산자를 두번 pop() 해 두 개 꺼낸다
- s.pop()2 +(연산자) s.pop()1 = 결과
- 계산결과 스택에 s.push()
- 후위표기식으로 변경
    
    ```python
    word = '(6+5*(2-8)/2)'
    
    stack = [0] * 100
    top = -1
    icp = {'(':3, '*':2, '/':2, '+':1, '-':1}
    isp = {'(':0, '*':2, '/':2, '+':1, '-':1}
    result = ''
    for w in word:
        if w not in '(+-*/)':
            result += w
        elif w == ')':
            while stack[top] != '(':
                result += stack[top]
                top -= 1
            top -= 1
        else:
            if top == -1 or isp[stack[top]] < icp[w]:
                top += 1
                stack[top] = w
            elif isp[stack[top]] >= icp[w]:
                while top > -1 and isp[stack[top]] >= icp[w]:
                    result += stack[top]
                    top -= 1
                top += 1
                stack[top] = w
    print(result)
    ```
    

### 백트래킹

- 해를 찾는 도중에 막히면(해가 아니면) 되돌아가서 다시 해를 찾아 가는 기법
- 백트래킹 기법으로 최적화 문제(optimization)와 결정 문제(decision) 해결 가능
- 결정 문제 : 문제의 조건을 만족하는 해가 존재하는지 여부를 ‘yes’/’no’ 답하는 문제
    - 미로찾기, n-Queen, Map coloring, 부분 집합의 합 문제
- 모든 후보 검사 X
- 어떤 노드의 유망성을 점검한 후에 유망하지 않다고 결정되면 그 노드의 부모로 되돌아가 다음 자식 노드로 감
- 어떤 노드를 방문하였을 때 그 노드를 포함한 경로가 해답이 될 수 없으면 그 노드는 유망하지 않다고 하며, 반대로 해당 가능성이 있으면 유망하다고 함
- 가지치기(prunning) : 유망하지 않은 노드가 포함되는 경로는 더 이상 고려하지 않는다
- 백트래킹 / 깊이우선탐색 차이
    - 어떤 노드에서 출발하는 경로가 해결책으로 이어질 것 같지 않으면 더 이상 그 경로를 따라가지 않음으로써 시도의 횟수를 줄임
        
        ⇒ Prunning 가지치기
        
    - 깊이우선탐색이 모든 경로를 추적하는데 비해 백트래킹은 불필요한 경로 조기에 차단
    - 깊이우선탐색을 가하기에는 경우의 수가 너무 많음
        
        ⇒ N! 가지의 경우의 수를 가진 문제에 대해 깊이우선탐색을 사용하면 처리 불가능한 문제
        
    - 백트래킹 알고리즘 적용 시 일반적으로 경우의 수가 줄어들지만 이 역시 최악의 경우 여전히 지수함수시간 요구하므로 처리 불가
- 알고리즘 절차
    1. 상태 공간 트리의 깊이 우선 검색 실시
    2. 각 노드가 유망한지 점검
    3. 만일 그 노드가 유망하지 않으면, 그 노드의 부모 노드로 돌아가서 검색 계속하기

```python
def checknode(v):
	if promising(v):
		if there is a solution at v:
			write the solution
		else:
			for u in each child of v:
				checknode(u)
```

### 미로찾기

- 스택을 이용하여 지나온 경로를 역으로 되돌아 감

### 부분집합 구하기

- 어떤 집합의 공집합과 자기자신을 포함한 모든 부분집합 = powerset
- 구하고자 하는 집합의 원소 개수가 n 일때 부분집합의 개수 = 2 ** n